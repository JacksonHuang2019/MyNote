![](https://camo.githubusercontent.com/64f6436c918c4f81a8beaa8ab2ffd71901bbe185/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30372f31392f3564333133663238396435373831313635362e6a7067)
## 前言
较长一段时间以来我都发现不少开发者对 jdk 中的 J.U.C（java.util.concurrent）也就是 Java 并发包的使用甚少，更别谈对它的理解了；但这却也是我们进阶的必备关卡。

之前或多或少也分享过相关内容，但都不成体系；于是便想整理一套与并发包相关的系列文章。

其中的内容主要包含以下几个部分：
1. 根据定义自己实现一个并发工具。
2. JDK 的标准实现。
3. 实践案例。

基于这三点我相信大家对这部分内容不至于一问三不知。

既然开了一个新坑，就不想做的太差；所以我打算将这个列表下的大部分类都讲到。

![](https://camo.githubusercontent.com/b65e2bb747286dc3975b1d3374743baaf885a881/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30372f31392f3564333133663263376639313435303038362e6a7067)

所以本次重点讨论 ArrayBlockingQueue。
## 自己实现
在自己实现之前先搞清楚阻塞队列的几个特点：
* 基本队列特性：先进先出。
* 写入队列空间不可用时会阻塞。
* 获取队列数据时当队列为空时将阻塞。

实现队列的方式多种，总的来说就是数组和链表；其实我们只需要搞清楚其中一个即可，不同的特性主要表现为数组和链表的区别。

这里的 ArrayBlockingQueue 看名字很明显是由数组实现。

我们先根据它这三个特性尝试自己实现试试。
## 初始化队列
我这里自定义了一个类：ArrayQueue，它的构造函数如下：

    public ArrayQueue(int size) {
            items = new Object[size];
    }
    
很明显这里的 items 就是存放数据的数组；在初始化时需要根据大小创建数组。

![](https://camo.githubusercontent.com/ecc85486288dd107abb81e39d2c879163df506f5/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30372f31392f3564333133663266623866653632323639322e6a7067)
## 写入队列
写入队列比较简单，只需要依次把数据存放到这个数组中即可，如下图：

![](https://camo.githubusercontent.com/161c69d6a97f1554dd06153503bc5eeebaec581a/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30372f31392f3564333133663332616137373638303038392e6a7067)

但还是有几个需要注意的点：
* 队列满的时候，写入的线程需要被阻塞。
* 写入过队列的数量大于队列大小时需要从第一个下标开始写。

先看第一个队列满的时候，写入的线程需要被阻塞，先来考虑下如何才能使一个线程被阻塞，看起来的表象线程卡住啥事也做不了。

有几种方案可以实现这个效果:
* Thread.sleep(timeout)线程休眠。
* 0bject.wait() 让线程进入 waiting 状态。

>当然还有一些 join、LockSupport.part 等不在本次的讨论范围。
阻塞队列还有一个非常重要的特性是：当队列空间可用时（取出队列），写入线程需要被唤醒让数据可以写入进去。

所以很明显Thread.sleep(timeout)不合适，它在到达超时时间之后便会继续运行；达不到<b>空间可用时</b>才唤醒继续运行这个特点。

其实这样的一个特点很容易让我们想到 Java 的等待通知机制来实现线程间通信；更多线程见通信的方案可以参考这里：[<b>深入理解线程通信</b>](https://crossoverjie.top/2018/03/16/java-senior/thread-communication/#%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6)

所以我这里的做法是，一旦队列满时就将写入线程调用 object.wait() 进入 waiting 状态，直到空间可用时再进行唤醒。

     /**
         * 队列满时的阻塞锁
         */
        private Object full = new Object();
    
        /**
         * 队列空时的阻塞锁
         */
        private Object empty = new Object();
        
 ![](https://camo.githubusercontent.com/3f0658e538c183f0ee0502a678e45456213e4486/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30372f31392f3564333133663335303338633634393532332e6a7067)
 
 