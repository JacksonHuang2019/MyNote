![](https://camo.githubusercontent.com/64f6436c918c4f81a8beaa8ab2ffd71901bbe185/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30372f31392f3564333133663238396435373831313635362e6a7067)
## 前言
较长一段时间以来我都发现不少开发者对 jdk 中的 J.U.C（java.util.concurrent）也就是 Java 并发包的使用甚少，更别谈对它的理解了；但这却也是我们进阶的必备关卡。

之前或多或少也分享过相关内容，但都不成体系；于是便想整理一套与并发包相关的系列文章。

其中的内容主要包含以下几个部分：
1. 根据定义自己实现一个并发工具。
2. JDK 的标准实现。
3. 实践案例。

基于这三点我相信大家对这部分内容不至于一问三不知。

既然开了一个新坑，就不想做的太差；所以我打算将这个列表下的大部分类都讲到。

![](https://camo.githubusercontent.com/b65e2bb747286dc3975b1d3374743baaf885a881/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30372f31392f3564333133663263376639313435303038362e6a7067)

所以本次重点讨论 ArrayBlockingQueue。
## 自己实现
在自己实现之前先搞清楚阻塞队列的几个特点：
* 基本队列特性：先进先出。
* 写入队列空间不可用时会阻塞。
* 获取队列数据时当队列为空时将阻塞。

实现队列的方式多种，总的来说就是数组和链表；其实我们只需要搞清楚其中一个即可，不同的特性主要表现为数组和链表的区别。

这里的 ArrayBlockingQueue 看名字很明显是由数组实现。

我们先根据它这三个特性尝试自己实现试试。
## 初始化队列
我这里自定义了一个类：ArrayQueue，它的构造函数如下：

    public ArrayQueue(int size) {
            items = new Object[size];
    }
    
很明显这里的 items 就是存放数据的数组；在初始化时需要根据大小创建数组。

![](https://camo.githubusercontent.com/ecc85486288dd107abb81e39d2c879163df506f5/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30372f31392f3564333133663266623866653632323639322e6a7067)
## 写入队列
